# Lesson 5: Form Validation

In this lesson, we will implement comprehensive form validation across all three steps of the trip logging process (Start Trip, Catch Log, and End Trip). This ensures users provide accurate, complete information before proceeding to each subsequent step. We'll add validation logic using React state management and display user-friendly error messages using USWDS `ErrorMessage` components.

## Step 1: Understanding Form Validation in RADFish Applications

Before implementing validation, let's understand the validation patterns used in RADFish applications and how they integrate with React state management.

### 1.1: Validation Architecture

Form validation in RADFish applications follows a consistent pattern across all form components:

1. **Validation Functions**: Pure functions that check field values against business rules
2. **Error State Management**: React state to store and display validation errors
3. **Submission Prevention**: Block navigation/submission when validation fails
4. **User Experience**: Clear, accessible error messages using USWDS components

### 1.2: Validation Types

Our trip logging application uses several validation types:

- **Required Field Validation**: Ensures essential fields are not empty
- **Data Type Validation**: Validates numbers, coordinates, and other specific formats
- **Range Validation**: Ensures numeric values fall within acceptable bounds
- **Business Logic Validation**: Custom rules specific to fishing trip data

**Key Validation Concepts:**

- **Client-Side Validation**: Immediate feedback without server round-trips
- **Accessible Error Messages**: Screen reader compatible with proper ARIA attributes
- **Form State Management**: Coordinating validation with React's controlled components
- **Progressive Enhancement**: Validation works even if JavaScript fails

## Step 2: Start Trip Form Validation

Let's begin by implementing validation for the Start Trip form, which collects the trip date, start time, and weather conditions.

### 2.1: Set Validation Error State

The Start Trip form uses React state to store validation errors. When the form is submitted, we need to validate all fields and update the error state.

Open `src/pages/StartTrip.jsx` and locate the `handleSubmit` function.

```jsx title="src/pages/StartTrip.jsx" showLineNumbers=178
  const handleSubmit = async (e) => {
    e.preventDefault();

    const newErrors = validateForm();
    //diff-add-start
    setErrors(newErrors);
    //diff-add-end

    if (Object.keys(newErrors).length === 0) {
```

**Explanation:**

- `validateForm()`: Calls the validation function that checks all form fields. We will take a look at this function in the next step.
- `setErrors(newErrors)`: Updates React state with the validation results

### 2.2: Required Field Validation Logic

The Start Trip form validates three required fields using a standardized validation helper:

```jsx title="src/pages/StartTrip.jsx" showLineNumbers=152
const validateRequired = (value, fieldName) => {
  if (!value || String(value).trim() === "") {
    return `${fieldName} is required`;
  }
  return null;
};

const validateForm = () => {
  const newErrors = {};

  const dateError = validateRequired(formData.tripDate, FIELD_DATE);
  if (dateError) newErrors.tripDate = dateError;

  const weatherError = validateRequired(formData.weather, FIELD_START_WEATHER);
  if (weatherError) newErrors.weather = weatherError;

  const timeError = validateRequired(formData.startTime, FIELD_START_TIME);
  if (timeError) newErrors.startTime = timeError;

  return newErrors;
};
```

**Understanding the Validation Pattern:**

- **Helper Function**: `validateRequired()` provides reusable validation logic
- **Field Constants**: `FIELD_DATE`, `FIELD_START_WEATHER`, etc. ensure consistent error messages
- **Error Object**: Returned object maps field names to error messages
- **Null Returns**: Valid fields return `null` to indicate no errors

### 2.3: Apply Error States to Form Components

The Start Trip form applies validation states to form components to provide visual feedback when errors occur:

```jsx title="src/pages/StartTrip.jsx" showLineNumbers=254
//diff-remove-start
<FormGroup>
//diff-remove-end
//diff-add-start
<FormGroup error={errors.tripDate}>
//diff-add-end
  <Label
    htmlFor="tripDate"
    //diff-add-start
    error={errors.tripDate}
    //diff-add-end
    hint=" mm/dd/yyyy"
    requiredMarker
  >
    Date
  </Label>
  <DatePicker
    id="tripDate"
    name="tripDate"
    defaultValue={formData.tripDate}
    onChange={handleDateChange}
    //diff-add-start
    validationStatus={errors.tripDate ? "error" : undefined}
    //diff-add-end
    aria-describedby="trip-date-hint trip-date-error-message"
    required
  />
  <span id="trip-date-hint" className="usa-sr-only">
    Please enter or select the date of your fishing trip.
  </span>
</FormGroup>
```

**Understanding the Error State Pattern:**

- **FormGroup Error State**: `error={errors.tripDate}` applies USWDS error styling to the entire form group
- **Label Error Integration**: `error={errors.tripDate}` on the Label component provides visual error indication
- **Input Validation Status**: `validationStatus={errors.tripDate ? "error" : undefined}` adds error styling to the DatePicker
- **ARIA Accessibility**: `aria-describedby="trip-date-hint trip-date-error-message"` links the input to both hint text and error messages

### 2.4: Import and Display Error Messages

To display validation error messages, we need to import the `ErrorMessage` component from USWDS and add it to our form fields.

**First, add the ErrorMessage import to your existing import statement:**

```jsx title="src/pages/StartTrip.jsx" showLineNumbers=5
import {
  Button,
  DatePicker,
  //diff-add-start
  ErrorMessage,
  //diff-add-end
  Form,
  FormGroup,
  Grid,
  GridContainer,
  Label,
  Select,
  StepIndicator,
  StepIndicatorStep,
  TimePicker,
} from "@trussworks/react-uswds";
```

**Then, add the conditional ErrorMessage component to each form field:**

```jsx title="src/pages/StartTrip.jsx" showLineNumbers=255
<FormGroup error={errors.tripDate}>
  <Label
    htmlFor="tripDate"
    error={errors.tripDate}
    hint=" mm/dd/yyyy"
    requiredMarker
  >
    Date
  </Label>
  <DatePicker
    id="tripDate"
    name="tripDate"
    defaultValue={formData.tripDate}
    onChange={handleDateChange}
    validationStatus={errors.tripDate ? "error" : undefined}
    aria-describedby="trip-date-hint trip-date-error-message"
    required
  />
  <span id="trip-date-hint" className="usa-sr-only">
    Please enter or select the date of your fishing trip.
  </span>
  //diff-add-start
  <ErrorMessage id="trip-date-error-message" className="font-sans-2xs">
    {errors.tripDate}
  </ErrorMessage>
  //diff-add-end
</FormGroup>
```

**Understanding Error Message Implementation:**

- **Conditional Content**: `{errors.tripDate}` only displays error text after form submission attempts - the ErrorMessage component handles empty content gracefully
- **Consistent ID Naming**: `id="trip-date-error-message"` follows kebab-case pattern for accessibility
- **ARIA Integration**: The ID matches the `aria-describedby` attribute on the input field
- **Styling**: `className="font-sans-2xs"` applies consistent USWDS error message styling

This pattern ensures errors are visually prominent, accessible to screen readers, and only appear when users attempt to submit invalid data.

### 2.5: Testing the Error Message Display

To verify that your validation is working correctly, follow these steps to recreate the error shown in the screenshot above:

1. **Navigate to the Start Trip page** (`/start`) in your application
2. **Leave the Date field empty** - don't select or enter any date
3. **Fill in the other required fields** (Time and Weather) with valid values
4. **Click the "Next" button** to attempt form submission

**Expected Results:**

- ✅ The form should **not** navigate to the next page
- ✅ The Date field should display a **red border** (error styling)
- ✅ The error message **"Trip date is required"** should appear below the Date field in red text
- ✅ The label should also display in **red** to indicate the error state

![DatePicker with error message](./src/assets/lesson-5_step-2.4.png)

**Additional Testing:**

- Try submitting with **all fields empty** - you should see error messages for all three required fields
- **Fill in the Date field** and submit again - the date error should disappear while other empty fields still show errors
- **Fill all fields correctly** - all errors should clear and the form should proceed to the Catch Log page

## Step 3: Catch Log Form Validation

The Catch Log page presents a more complex validation scenario with both a "new catch" form and a list of existing catches that can be edited.

### 3.1: New Catch Validation

The "Add Catch" form validates species, weight, length, time, and optional coordinates before adding to the list.

Open `src/pages/CatchLog.jsx` and locate the `handleAddCatch` function. Observe how validation is implemented:

```jsx title="src/pages/CatchLog.jsx" showLineNumbers=277
const handleAddCatch = async (e) => {
  e.preventDefault();

  //diff-remove-start
  const formErrors = {};
  //diff-remove-end
  //diff-add-start
  const formErrors = validateForm();
  setErrors(formErrors);
  //diff-add-end

  if (Object.keys(formErrors).length === 0 && tripId) {
    try {
};
```

**Complex Validation Rules:**

The Catch Log uses multiple validation types beyond simple required field checks:

```jsx title="src/pages/CatchLog.jsx" showLineNumbers=42
const validateNumberRange = (value, min, max, fieldName, allowZero = true) => {
  if (value === "" || value === null || value === undefined) return null;
  const numValue = Number(value);
  if (isNaN(numValue)) return `${fieldName} must be a valid number`;
  if (!allowZero && numValue <= min)
    return `${fieldName} must be greater than ${min}`;
  if (allowZero && numValue < min)
    return `${fieldName} must be at least ${min}`;
  if (numValue > max) {
    const minOperator = allowZero ? ">=" : ">";
    return `${fieldName} must be ${minOperator} ${min} and <= ${max}`;
  }
  return null;
};

const validateLatitude = (value) => {
  if (value === "" || value === null || value === undefined) return null;
  const numValue = Number(value);
  if (isNaN(numValue)) return `${FIELD_LATITUDE} must be a valid number`;
  if (numValue < -90 || numValue > 90)
    return `${FIELD_LATITUDE} must be between -90 and 90`;
  return null;
};
```

**Advanced Validation Features:**

- **Range Validation**: Weight (0-1000 lbs) and length (0-500 inches) must be within realistic bounds
- **Coordinate Validation**: Latitude (-90 to 90) and longitude (-180 to 180) follow geographic standards
- **Optional Field Handling**: Coordinates are validated only if values are provided
- **Type Coercion**: Automatic conversion from string inputs to numbers

### 3.2: Apply Error Display to Species Field

Now let's apply the validation display pattern you learned from the Start Trip form to the Species field in the Catch Log. The validation logic is already implemented, but we need to add the visual error states.

**Note:** The `ErrorMessage` component has already been imported for you, and all other form fields in this component already have error validation set up. We'll focus on just the Species field as an example.
Locate the Species FormGroup and apply the same error display pattern from the Start Trip form:

```jsx title="src/pages/CatchLog.jsx" showLineNumbers=461
//diff-remove-start
<FormGroup >
//diff-remove-end
//diff-add-start
<FormGroup error={errors.species}>
//diff-add-end
  <Label
    htmlFor="species"
    //diff-add-start
    error={errors.species}
    //diff-add-end
    requiredMarker
  >
    Species
  </Label>
  <Select
    id="species"
    name="species"
    value={currentCatch.species}
    onChange={handleInputChange}
    //diff-add-start
    validationStatus={errors.species ? "error" : undefined}
    aria-describedby="species-error-message"
    //diff-add-end
  >
    <option value="">-Select-</option>
    {SPECIES_OPTIONS.map((species) => (
      <option key={species} value={species}>
        {species}
      </option>
    ))}
  </Select>
  //diff-add-start
  <ErrorMessage id="species-error-message" className="font-sans-2xs">
    {errors.species}
  </ErrorMessage>
  //diff-add-end
</FormGroup>
```

### 3.3: Testing Complete Form Validation

When you submit the form with invalid data, you should see multiple validation errors:

- **Species is required** - When dropdown is left at "-Select-"
- **Weight must be greater than 0** - When weight is set to 0
- **Length must be > 0 and ≤ 500** - When length exceeds 500 inches
- **Catch time is required** - When no time is selected
- **Latitude must be between -90 and 90** - When latitude is invalid (like 900)
- **Longitude must be between -180 and 180** - When longitude is invalid (like -200)

All fields show red borders, red labels, and specific error messages below each input.

![Catch Log errors](./src/assets/lesson-5_step-3.2.png)

### 3.4: Recorded Catches Validation

The recorded catches list also has validation set up the same way as the new catch form. When you click "Next" to proceed to the End Trip page, all catches in the "Recorded Catches" list are validated using the same rules and error display patterns you've learned.

This validation is already implemented for you - it prevents navigation to the next step if any recorded catches have invalid data.

### 3.5: Error Display for Recorded Catches

The recorded catches list uses the same error display pattern, but with unique IDs for each catch item (like `recorded-species-0`, `recorded-species-1`, etc.). This is already implemented for you throughout the recorded catches section.

## Step 4: Apply Validation to End Trip (Practice Exercise)

Now it's your turn! Apply the validation patterns you've learned to the End Trip form. This form needs validation for the trip's end time and weather conditions before allowing users to review their complete trip data.

However, before we can add validation, we need to complete the End Trip form implementation since it's currently missing the required fields and components.

### 4.1: Update the Data Model

First, you need to enable the `endTime` and `endWeather` fields in the data model.

Your task is to add the `endTime` and `endWeather` fields to the trip model.

:::info Hint
Models are defined in `src/index.jsx`.
:::

:::warning Multi-Step Form Consideration
Since this is a multi-step form, you need to handle the fact that `endTime` and `endWeather` won't be available when the trip is first created in the StartTrip form.

**The Problem:** If you make these fields `required: true` in the model, the StartTrip form will fail validation when trying to create the initial trip record because these fields don't exist yet.

**The Solutions:**

1. **Option 1**: Make the fields optional in the model (`required: false`)
2. **Option 2**: Set them to empty strings when creating the initial trip

**Recommended Approach:** Use Option 2 and update the `Form.create()`:

```jsx title="src/pages/StartTrip.jsx" showLineNumbers=224
// Look for the Form.create call around line 241 and update it to:
await Form.create({
  id: newTripId,
  ...tripData,
  //diff-add-start
  endTime: "",
  endWeather: "",
  //diff-add-end
});
```

This allows the trip to be created successfully at the start, and these fields will be populated later in the EndTrip form.
:::

### 4.2: Import Required Components

Open `src/pages/EndTrip.jsx` and add the missing component imports.

**Your task:** Add the necessary imports at the top of the file.

**Components you'll need:**
:::info Hint  
Look at `src/pages/StartTrip.jsx` to see what components are needed for:

- Time input field
- Weather dropdown
- Error message display
  :::

### 4.3: Add Form Fields to the Component

The End Trip form currently only has navigation buttons. You need to add the actual form fields.

**Fields to add:**

1. **End Time field** - similar to the startTime field in Start Trip
2. **End Weather field** - similar to the weather field in Start Trip

:::info Hint
You'll need:

- FormGroup with proper error state
- Label with required marker and error state
- Input component with validation status
- Conditional ErrorMessage component
  :::

### 4.4: Add Form State Management

You'll need to add state management for the form data and handle changes.

:::info Hint
You'll need to add the following:

- formData state for storing field values
- handleTimeChange function for time picker
- handleSelectChange function for dropdowns
- Form initialization from database/localStorage
  :::

### 4.5: Implement Validation Logic

Finally, add the validation patterns you learned from the previous forms.

**For validation functions:**

:::info Hint

- Copy the validateRequired helper from `src/pages/StartTrip.jsx`
- Add validateForm function that checks both endTime and endWeather
- Use the same field constants pattern (FIELD_END_TIME, FIELD_END_WEATHER)
  :::

**For setting validation errors:**

:::info Hint

- Use the same pattern as Start Trip
- const newErrors = validateForm();
  :::

**For displaying error messages:**

:::info Hint

- Follow the same pattern as previous forms
- Remember to:
  - Add error prop to FormGroup
  - Add error prop to Label
  - Add validationStatus to the input component
  - Add conditional ErrorMessage component
  - Use proper aria-describedby for accessibility
    :::

## Step 5: Testing Complete Validation Flow

Test the validation system with both invalid and valid data to ensure it works correctly:

### 5.1: Complete Validation Test

1. **Start Trip (`/start`)**:

   - Try submitting empty form → verify error messages appear
   - Fill fields correctly → proceeds to Catch Log

2. **Catch Log (`/catch`)**:

   - Try "Add Catch" with empty fields → verify validation errors
   - Test invalid coordinates (latitude > 90) → verify range validation
   - Add valid catches → try "Next" with invalid recorded catches → verify list validation
   - Ensure all catches are valid → proceeds to End Trip

3. **End Trip (`/end`)**:
   - Try submitting without end time/weather → verify validation blocks navigation
   - Fill fields correctly → proceeds to Review page

**Expected Results:**

- ✅ Errors appear only after submission attempts
- ✅ Invalid data blocks navigation between steps
- ✅ Error styling applied consistently across all forms
- ✅ Valid data clears errors and allows progression

## Conclusion

You have successfully implemented comprehensive form validation across all three steps of the trip logging process!

**Key Benefits:**

- **Data quality**: Ensures complete, accurate trip information
- **User experience**: Clear guidance when data doesn't meet requirements
- **Accessibility**: Screen reader compatible with proper labeling
- **Progressive enhancement**: Validation works even if JavaScript fails

In the next lesson, we'll implement the review page where users can see all their trip data before final submission.
